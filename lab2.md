# Lab 2: Bluetooth

## Prelab

### Setup

For this lab, using Terminal, I installed the latest releases of Python and pip. I also activated the virtual environment and installed the necessary Python packages using the command _pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab_. Additionally, I started the Jupyter server. I then burned the ble_arduino.ino sketch onto the Artemis, after which the Artemis printed its MAC address to the serial monitor.

<img width="493" alt="Screen Shot 2023-02-14 at 1 37 01 AM" src="https://user-images.githubusercontent.com/123786420/218658420-61b187a6-2461-445f-9a06-b281ad76ecea.png">




### Codebase

In the project directory I created, I added the unzipped codebase, as well as the _ble_python_ directory. Some important functions included in this codebase are **uuid4()**, **writeValue(value)**, **clear()**, **append()**, **c_str()**, and **handle_command()**.




## Lab Tasks

### Configurations

I first updated the default MAC address of the Artemis with a new address generated by the command **uuid()** in the file connections.yaml. In both ble_arduino.ino and connections.yaml, I replaced I replaced the BLE service UUID with the generated address. The screenshot below shows that the new MAC address was successfully used to establish a connection.

<img width="798" alt="Screen Shot 2023-02-15 at 2 39 00 AM" src="https://user-images.githubusercontent.com/123786420/218962948-cccc4090-757b-4fd0-b0a4-e11abe3ec9b3.png">



### Demo.ipynb

As seen in the screenshot below, I was able to run the given demo.ipynb file succesfully.

<img width="935" alt="Screen Shot 2023-02-15 at 2 40 10 AM" src="https://user-images.githubusercontent.com/123786420/218963224-576cf78e-28a4-40c3-8efb-e2ca52a98a72.png">

The Artemis was able to receive the two integers and print them to the serial monitor.

<img width="632" alt="Screen Shot 2023-02-15 at 2 41 08 AM" src="https://user-images.githubusercontent.com/123786420/218963486-378dd260-6d4a-44ae-ab1c-06a7d8c34790.png">



### Send Echo Command

For this task, I create a case **ECHO** in the function **handle_commands()** in the ble_arduino.ino file, which when called from the Python end using the function **send_command**, appends the characters ":)" to the input and sends the augmented string as a response. 

<img width="531" alt="Screen Shot 2023-02-14 at 1 18 26 AM" src="https://user-images.githubusercontent.com/123786420/218655199-6198ac64-b05c-4bc1-a895-d641f76fcd39.png">

<img width="367" alt="Screen Shot 2023-02-14 at 1 15 47 AM" src="https://user-images.githubusercontent.com/123786420/218654749-e67275c2-ad16-4342-88d1-a101a21aa4a6.png">



### Get Time Command

For this task, I create a case **GET_TIME_MILLIS** in the function **handle_commands()** in the ble_arduino.ino file, which when called from the Python end, appends sends the time in milliseconds, found using the function **millis()**, in the form "T:time" in response.

<img width="474" alt="Screen Shot 2023-02-14 at 1 18 51 AM" src="https://user-images.githubusercontent.com/123786420/218655258-d217368c-9cae-40f8-95f6-1dae2eeb5c37.png">

<img width="365" alt="Screen Shot 2023-02-15 at 2 41 41 AM" src="https://user-images.githubusercontent.com/123786420/218963616-8febdda1-d0be-4212-9b4d-0131cdf6a347.png">



### Notification Handler

I set up a notification handler in Python to receive the string values the Artemis board sends in response to commands from the Python end. I defined a callback function **callback(uuid,byte_array)** that converts the received byte array of a characteristic string with a particular UUID into a string. To extract the time from the string, I sliced it to remove the first two characters. Then, to start notifications, I called the function **start_notify** with the UUID of the characteristic string and the callback function as parameters. Next, I sent the **GET_TIME_MILLIS** command from the Python end to the Artemis, and I was able to print the received string without calling the function **receive_string**, showing that the notification handler worked. Finally, I called the function **stop_notify** to cease notifications. No code was added on the Arduino end.

<img width="425" alt="Screen Shot 2023-02-14 at 1 32 14 AM" src="https://user-images.githubusercontent.com/123786420/218657609-b3f596d8-9b9a-4068-98cd-9e6ba658ca27.png">



### Get Temperature Commands

#### GET_TEMP_5s

For this task, I create a case **GET_TEMP_5s** in the function **handle_commands()** in the ble_arduino.ino file, which when called from the Python end, sends a string with 5 timestamped internal die temperature readings (in Celsius), with the readings being taken once per second for five seconds. This string was created by appending a time reading, found using the function **millis()**, and a temperature reading, found using the function **getTempDegC()**, to the characteristic string five times using a loop, with each loop separated by a 1000 millisecond delay. 

<img width="467" alt="Screen Shot 2023-02-14 at 1 28 05 AM" src="https://user-images.githubusercontent.com/123786420/218656853-76bb3287-8d42-4582-b1ce-3bd01067f671.png">

On the Python end, I added a notification handler the same way as in the section above. I used the same callback function to start notifications, sent the **GET_TEMP_5s** command, printed the string, and stopped notifications.

<img width="725" alt="Screen Shot 2023-02-14 at 1 36 18 AM" src="https://user-images.githubusercontent.com/123786420/218658293-2ea18a39-fd79-4e6c-8d03-f16b76e1054b.png">




#### GET_TEMP_5s_RAPID

For this task, I create a case **GET_TEMP_5s_RAPID** in the function **handle_commands()** in the ble_arduino.ino file, which when called from the Python end, rapidly sends timestamped internal die temperature readings (in Celsius), all taken within 5 seconds. In the code for this case, a while loop is run for 5000 milliseconds, or 5 seconds, during which time as many timestamped temperature readings as possible are sent. There is also a 10 millisecond delay between samples to prevent duplicate samples from being sent.


<img width="476" alt="Screen Shot 2023-02-15 at 5 05 03 AM" src="https://user-images.githubusercontent.com/123786420/218996979-61a59f50-053b-4316-859b-cb5765ff0092.png">


On the Python end, I modified my existing callback function to append each received string to a list to create a list of timestamped temperature readings. I then used that callback function to start notifications, sent the **GET_TEMP_5s_RAPID** command, printed the string, printed the length of the list to verify that more than 50 samples were collected, and stopped notifications.


<img width="900" alt="Screen Shot 2023-02-15 at 5 04 11 AM" src="https://user-images.githubusercontent.com/123786420/218996795-ff5a020f-4e0f-40bb-b976-4d2b1e52f5a9.png">
<img width="897" alt="Screen Shot 2023-02-15 at 5 04 43 AM" src="https://user-images.githubusercontent.com/123786420/218996890-a902ee2f-0de3-496f-944e-27d6cfa39314.png">


### Limitations

One second of a 16-bit values sent at 150 Hz would take 2400 bits of memory, or 0.3 kB. This means that 384 kB of RAM could store 384/0.3 = 1280 seconds, or 21 minutes and 20 seconds, of 16-bit values at 150 Hz. However, this is assuming that all of the space on the RAM is available, but in reality, the amount of data that can be stored is probably less than the calculated value.


